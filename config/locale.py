import re

def escape_markdown_v2(text: str) -> str:
    # –≠–∫—Ä–∞–Ω–∏—Ä—É–µ–º –≤—Å–µ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã –¥–ª—è MarkdownV2
    return re.sub(r'([_*\[\]()~`>#+\-=|{}.!])', r'\\\1', text)

class Locale:
    def __init__(self):
        self.translations = {
            'en': {
                'greeting': 'Hello! Welcome to the vpn shop!',
                'choose_rate': 'Choose a plan',
                'buy_sub': 'Buy a subscription',
                'show_sub': 'Show subscription',
                'back': '‚¨ÖÔ∏è Back',
                'cancel': '‚ùå Cancel',
                'confirm': '‚úÖ Confirm',
                'rate_selected': 'You have selected:',
                'confirm_purchase': '‚úÖ Buy this plan',
                'change_rate': 'üîÑ Choose another plan',
                'confirm_question': 'Confirm your purchase:',
                'error_loading_rates': 'Error loading plans',
                'rate_not_found': 'Plan not found',
                'choose_payment': 'Choose payment method:',
                'pay_card': 'üí≥ Bank Card',
                'pay_crypto': '‚Çø Cryptocurrency', 
                'pay_stars': 'ü•ù Stars',
                'subscription_info': 'Your subscription:',
                'subscription_active': '‚úÖ Active',
                'subscription_expired': '‚ùå Expired',
                'subscription_expires': 'Expires:',
                'no_subscription': "You don't have an active subscription",
                'loading': '‚è≥ Loading...',
                'success': '‚úÖ Success!',
                'error': '‚ùå Error',
                'try_again': 'üîÑ Try again'
            },
            'ru': {
                'greeting': '–ü—Ä–∏–≤–µ—Ç! –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –º–∞–≥–∞–∑–∏–Ω vpn!',
                'choose_rate': '–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∞—Ä–∏—Ñ',
                'buy_sub': '–ö—É–ø–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É',
                'show_sub': '–ü–æ–∫–∞–∑–∞—Ç—å –ø–æ–¥–ø–∏—Å–∫—É',
                'back': '‚¨ÖÔ∏è –ù–∞–∑–∞–¥',
                'cancel': '‚ùå –û—Ç–º–µ–Ω–∞',
                'confirm': '‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å',
                'rate_selected': '–í—ã –≤—ã–±—Ä–∞–ª–∏:',
                'confirm_purchase': '‚úÖ –ö—É–ø–∏—Ç—å —ç—Ç–æ—Ç —Ç–∞—Ä–∏—Ñ',
                'change_rate': 'üîÑ –í—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥–æ–π —Ç–∞—Ä–∏—Ñ',
                'confirm_question': '–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –ø–æ–∫—É–ø–∫—É:',
                'error_loading_rates': '–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ç–∞—Ä–∏—Ñ–æ–≤',
                'rate_not_found': '–¢–∞—Ä–∏—Ñ –Ω–µ –Ω–∞–π–¥–µ–Ω',
                'choose_payment': '–í—ã–±–µ—Ä–∏—Ç–µ —Å–ø–æ—Å–æ–± –æ–ø–ª–∞—Ç—ã:',
                'pay_card': 'üí≥ –ë–∞–Ω–∫–æ–≤—Å–∫–∞—è –∫–∞—Ä—Ç–∞',
                'pay_crypto': '‚Çø –ö—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–∞',
                'pay_stars': 'ü•ù –ó–≤–µ–∑–¥—ã', 
                'subscription_info': '–í–∞—à–∞ –ø–æ–¥–ø–∏—Å–∫–∞:',
                'subscription_active': '‚úÖ –ê–∫—Ç–∏–≤–Ω–∞',
                'subscription_expired': '‚ùå –ò—Å—Ç–µ–∫–ª–∞',
                'subscription_expires': '–ò—Å—Ç–µ–∫–∞–µ—Ç:',
                'no_subscription': '–£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –ø–æ–¥–ø–∏—Å–∫–∏',
                'loading': '‚è≥ –ó–∞–≥—Ä—É–∑–∫–∞...',
                'success': '‚úÖ –£—Å–ø–µ—à–Ω–æ!',
                'error': '‚ùå –û—à–∏–±–∫–∞',
                'try_again': 'üîÑ –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–Ω–æ–≤–∞'
            }
        }

    def get(self, key, message=None):
        user_lang = 'en'
        
        if message:
            if hasattr(message, 'message') and hasattr(message.message, 'from_user'):
                user_lang = getattr(message.message.from_user, 'language_code', 'en')
            elif hasattr(message, 'from_user') and hasattr(message.from_user, 'language_code'):
                user_lang = message.from_user.language_code

        translations = self.translations.get(user_lang, self.translations['en'])

        return escape_markdown_v2(translations.get(key, key))

    def add_translation(self, lang: str, key: str, value: str):
        if lang not in self.translations:
            self.translations[lang] = {}
        self.translations[lang][key] = value

    def get_supported_languages(self):
        return list(self.translations.keys())

    def get_all_keys(self):
        all_keys = set()
        for lang_dict in self.translations.values():
            all_keys.update(lang_dict.keys())
        return sorted(list(all_keys))
